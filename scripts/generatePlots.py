#!/usr/bin/python

# generatePlots.py
# This is a script for generating plots for data generated by the real time 
# search project.  The input is any number of result files in JSON format.  The 
# configuration entries will be read and the algorithms and domains will be 
# automatically separated.

import getopt
import json
import matplotlib.cbook as cbook
import matplotlib.pyplot as plt
import numpy as np
import os
import sys
from scipy import stats

import plotUtils

ALGORITHM = 0
DOMAIN = 1

script = os.path.basename(sys.argv[0])
options = "hs:q"


def usage():
    print "usage:"
    print "{} [{}] file1 file2 ...".format(script, options)
    print "options:"
    print "  h         print this usage info"
    print "  s<file>   save to file"
    print "  q         quiet mode; no logging or graph showing"


save_file = None
quiet = False

try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], options)
except getopt.GetoptError:
    usage()
    sys.exit(2)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage()
        sys.exit(0)
    elif opt in ('-s', '--save'):
        save_file = arg
    elif opt in ('-q', '--quiet'):
        quiet = True
    else:
        print "invalid switch", opt
        usage()
        sys.exit(2)

# Process files from command line
num_files = len(args)
if len(args) == 0:
    print "ERROR: No files provided"
    usage()
    sys.exit(2)

times = {}
domain_counts = {}
algorithm_counts = {}
num_domains = 0
num_algorithms = 0
for json_file in args:
    if os.path.exists(json_file):
        f = open(json_file, 'r')
        if not quiet:
            print "File: ", json_file
        results = plotUtils.Results(json.loads(f.read()))

        if results.configuration not in times:
            times[results.configuration] = []
        times[results.configuration].append(results.time)

        # Checking for common domain
        if results.configuration[DOMAIN] not in domain_counts:
            domain_counts[results.configuration[DOMAIN]] = 0
            num_domains += 1
        else:
            domain_counts[results.configuration[DOMAIN]] += 1

        # Checking for common algorithms
        if results.configuration[ALGORITHM] not in algorithm_counts:
            algorithm_counts[results.configuration[ALGORITHM]] = 0
            num_algorithms += 1
        else:
            algorithm_counts[results.configuration[ALGORITHM]] += 1

        if not quiet:
            print "== Configuration =="
            print "Algorithm: ", results.configuration[ALGORITHM]
            print "Domain: ", results.configuration[DOMAIN]

            print "== Results =="
            print "Generated Nodes: ", results.generatedNodes
            print "Expanded Nodes: ", results.expandedNodes
            print "Path length: ", len(results.actions)
            print "Time (ns): ", results.time

            print
    else:
        if not quiet:
            print "Skipping non-existent file '%s'" % json_file

# TODO cleanup and remove code duplication
domain_groups = True
if num_domains != 1:
    if num_algorithms < num_domains:
        print "Data grouped by algorithm, not by domain..."
        domain_groups = False
        if num_algorithms != 1:
            print "Removing extra algorithms..."
            # Get max algorithm count
            max_algorithm = None
            max_count = 0
            for key, value in algorithm_counts.iteritems():
                if value > max_count:
                    max_count = value
                    max_algorithm = key
            # Remove data from other algorithms
            for key, value in times.items():
                if key.algorithm != max_algorithm:
                    del times[key]
                    num_algorithms -= 1
    else:
        print "Removing extra domains..."
        # Get max domain count
        max_domain = None
        max_count = 0
        for key, value in domain_counts.iteritems():
            if value > max_count:
                max_count = value
                max_domain = key
        # Remove data from other domains
        for key, value in times.items():
            if key[DOMAIN] != max_domain:
                del times[key]
                num_domains -= 1

# print times
# data = np.concatenate(times.values())
data = times.values()
# print data
# datadata = np.array(data)

# print data
# print datadata
# print datadata.reshape(len(data[0]), len(data))

plt.ylabel("Goal Achievement Time (ms)")
labels = []
if domain_groups:
    assert num_domains == 1
    plt.xlabel("Algorithm")
    plt.title(plotUtils.translate_domain_name(domain_counts.keys()[0]))
    for key in times.keys():  # Assumes same order will be plotted
        labels.append(plotUtils.translate_algorithm_name(key[ALGORITHM]))
else:
    assert num_algorithms == 1
    plt.xlabel("Domain")
    plt.title(plotUtils.translate_algorithm_name(algorithm_counts.keys()[0]))
    for key in times.keys():
        labels.append(plotUtils.translate_domain_name(key[DOMAIN]))

# print len(data)
x = np.arange(1, len(data) + 1)
y = data
# print x
# print y

# Get medians and stderr
# med = np.median(y, axis=1) # Can't do this way for uneven data points (no axis 1)
# sem = stats.sem(y, axis=1)
med = []
sem = []
std = []
for subdata in y:
    med.append(np.median(subdata))
    sem.append(stats.sem(subdata))
    std.append(np.std(subdata))

bxpstats = cbook.boxplot_stats(y)
confidence_intervals = [[], []]
for stat in bxpstats:
    confidence_intervals[0].append(stat['cilo'])
    confidence_intervals[1].append(stat['cihi'])
confidence_intervals[0] = np.array(confidence_intervals[0])
confidence_intervals[1] = np.array(confidence_intervals[1])

# plt.rcParams.update({'font.size': 14})
plt.boxplot(y, notch=False, labels=labels)
plt.errorbar(x, med, yerr=(med - confidence_intervals[0], confidence_intervals[1] - med), fmt='none', linewidth=3)

# Save before showing since show resets the figures
if save_file is not None:
    filename, ext = os.path.splitext(save_file)
    if ext is '.pdf':
        from matplotlib.backends.backend_pdf import PdfPages

        pp = PdfPages(save_file)
        plt.savefig(pp, format='pdf')
        pp.close()
    else:
        # Try and save it
        plt.savefig(save_file)

if not quiet:
    print "Plotting..."
    plt.show()
