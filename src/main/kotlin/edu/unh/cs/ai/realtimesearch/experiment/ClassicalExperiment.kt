package edu.unh.cs.ai.realtimesearch.experiment

import edu.unh.cs.ai.realtimesearch.agent.ClassicalAgent
import edu.unh.cs.ai.realtimesearch.environment.Action
import edu.unh.cs.ai.realtimesearch.environment.Domain
import edu.unh.cs.ai.realtimesearch.environment.State
import edu.unh.cs.ai.realtimesearch.experiment.configuration.ExperimentConfiguration
import edu.unh.cs.ai.realtimesearch.logging.info
import edu.unh.cs.ai.realtimesearch.logging.warn
import org.slf4j.LoggerFactory

/**
 * An experiments meant for classical search, such as depth first search.
 * An single run means requesting the agent to return a plan given an initial state.
 *
 * You can either run experiments on a specific state, or have them randomly
 * generated by the domain.
 *
 * NOTE: assumes the same domain is used to create both the agent as this class
 *
 * @param agent is the agent that is involved in the experiment
 * @param domain is the domain of the agent. Used for random state generation
 * @param initState is the optional initial state
 * @param runs is the amount of runs you want the experiment to do
 *
 */
class ClassicalExperiment<StateType : State<StateType>>(val experimentConfiguration: ExperimentConfiguration,
                                                        val agent: ClassicalAgent<StateType>,
                                                        val domain: Domain<StateType>,
                                                        val initState: State<StateType>? = null,
                                                        runs: Int = 1) : Experiment(runs) {

    private val logger = LoggerFactory.getLogger(ClassicalExperiment::class.java)
    private var actions: List<Action> = emptyList()

    override fun run(): List<ExperimentResult> {
        val results: MutableList<ExperimentResult> = arrayListOf()

        for (run in 1..runs) {
            // do experiment on state, either given or randomly created
            val state: StateType = initState?.copy() ?: domain.randomState()
            logger.warn { "Starting experiment run $run with state $state on agent $agent" }

            // TODO: complains should be from kotlin.system, but does not seem to exist
            val timeInMillis = kotlin.system.measureTimeMillis { actions = agent.plan(state) }

            // log results
            logger.info { "Path: [${actions.size}] $actions\nAfter ${agent.planner.expandedNodeCount} expanded and ${agent.planner.generatedNodeCount} generated nodes" }


            results.add(ExperimentResult(experimentConfiguration, agent.planner.generatedNodeCount, agent.planner.generatedNodeCount, timeInMillis, actions))
        }

        return results

    }
}