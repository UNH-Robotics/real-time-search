package edu.unh.cs.ai.realtimesearch.experiment

import edu.unh.cs.ai.realtimesearch.agent.ClassicalAgent
import edu.unh.cs.ai.realtimesearch.environment.Action
import edu.unh.cs.ai.realtimesearch.environment.Domain
import edu.unh.cs.ai.realtimesearch.environment.State
import edu.unh.cs.ai.realtimesearch.experiment.configuration.GeneralExperimentConfiguration
import edu.unh.cs.ai.realtimesearch.experiment.result.ExperimentResult
import edu.unh.cs.ai.realtimesearch.logging.info
import org.slf4j.LoggerFactory

/**
 * An experiments meant for classical search, such as depth first search.
 * An single run means requesting the agent to return a plan given an initial state.
 *
 * You can either run experiments on a specific state, or have them randomly
 * generated by the domain.
 *
 * NOTE: assumes the same domain is used to create both the agent as this class
 *
 * @param agent is the agent that is involved in the experiment
 * @param domain is the domain of the agent. Used for random state generation
 * @param initState is the optional initial state
 *
 */
class ClassicalExperiment<StateType : State<StateType>>(val experimentConfiguration: GeneralExperimentConfiguration,
                                                        val agent: ClassicalAgent<StateType>,
                                                        val domain: Domain<StateType>,
                                                        val initState: State<StateType>? = null) : Experiment() {

    private val logger = LoggerFactory.getLogger(ClassicalExperiment::class.java)
    private var actions: List<Action> = emptyList()

    override fun run(): ExperimentResult {
        // do experiment on state, either given or randomly created
        val state: StateType = initState?.copy() ?: domain.randomState()
        //        logger.warn { "Starting experiment with state $state on agent $agent" }

        val cpuNanoTime = measureThreadCpuNanoTime {
            actions = agent.plan(state)
        }

        // log results
        val pathLength = actions.size.toLong()
        logger.info { "Path length: [$pathLength] After ${agent.planner.expandedNodeCount} expanded and ${agent.planner.generatedNodeCount} generated nodes" }

        return ExperimentResult(
                experimentConfiguration = experimentConfiguration.valueStore,
                expandedNodes = agent.planner.expandedNodeCount,
                generatedNodes = agent.planner.generatedNodeCount,
                planningTime = cpuNanoTime,
                actionExecutionTime = pathLength * experimentConfiguration.actionDuration,
                goalAchievementTime = cpuNanoTime + pathLength * experimentConfiguration.actionDuration,
                idlePlanningTime = cpuNanoTime,
                pathLength = pathLength,
                actions = actions.map { it.toString() })

    }
}