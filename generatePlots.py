#!/usr/bin/python

# generatePlots.py
# This is a script for generating plots for data generated by the real time 
# search project.  The input is any number of result files in JSON format.  The 
# configuration entries will be read and the algorithms and domains will be 
# automatically separated.

import getopt
import json
import matplotlib.pyplot as plt
import numpy as np
import os
import re
import sys
from scipy import stats

ALGORITHM = 0
DOMAIN = 1

script = os.path.basename(sys.argv[0])
options = "hs:q"


def usage():
    print "usage:"
    print "{} [{}] file1 file2 ...".format(script, options)
    print "options:"
    print "  h         print this usage info"
    print "  s<file>   save to file"
    print "  q         quiet mode; no logging or graph showing"


def cnv_ns_to_ms(ns):
    return ns / 1000000.0


class Results:
    def __init__(self, parsedJson):
        self.configuration = (parsedJson['experimentConfiguration']['algorithmName'],
                              parsedJson['experimentConfiguration']['domainName'])
        self.generatedNodes = parsedJson['generatedNodes']
        self.expandedNodes = parsedJson['expandedNodes']
        self.actions = parsedJson['actions']
        self.time = cnv_ns_to_ms(parsedJson['goalAchievementTime'])


def translateAlgorithmName(algName):
    # Handle hat (^) names
    algName = re.sub(r"_(.*)_(HAT)", r"_\\hat{\1}", algName)
    # Specific word formatting
    algName = algName.replace('DYNAMIC', 'Dynamic')
    algName = algName.replace('WEIGHTED', 'Weighted')
    algName = algName.replace('LSS_', 'LSS-')
    # Handle star (*) names
    algName = algName.replace('_STAR', '*')
    # Replace rest of underscores
    algName = algName.replace('_', ' ')
    return algName


def translateDomainName(domainName):
    # Replace underscores
    domainName = domainName.replace('_', ' ')
    # Convert case
    domainName = domainName.title()
    return domainName

saveFile = None
quiet = False

try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], options)
except getopt.GetoptError:
    usage()
    sys.exit(2)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage()
        sys.exit(0)
    elif opt in ('-s', '--save'):
        saveFile = arg
    elif opt in ('-q', '--quiet'):
        quiet = True
    else:
        print "invalid switch", opt
        usage()
        sys.exit(2)

# Process files from command line
numFiles = len(args)
if len(args) == 0:
    print "ERROR: No files provided"
    usage()
    sys.exit(2)

times = {}
domainCounts = {}
algorithmCounts = {}
numDomains = 0
numAlgorithms = 0
for jsonFile in args:
    if os.path.exists(jsonFile):
        f = open(jsonFile, 'r')
        results = Results(json.loads(f.read()))

        if results.configuration not in times:
            times[results.configuration] = []
        times[results.configuration].append(results.time)

        # Checking for common domain
        if results.configuration[DOMAIN] not in domainCounts:
            domainCounts[results.configuration[DOMAIN]] = 0
            numDomains += 1
        else:
            domainCounts[results.configuration[DOMAIN]] += 1

        # Checking for common algorithms
        if results.configuration[ALGORITHM] not in algorithmCounts:
            algorithmCounts[results.configuration[ALGORITHM]] = 0
            numAlgorithms += 1
        else:
            algorithmCounts[results.configuration[ALGORITHM]] += 1

        if not quiet:
            print "File: ", jsonFile
            print "== Configuration =="
            print "Algorithm: ", results.configuration[ALGORITHM]
            print "Domain: ", results.configuration[DOMAIN]

            print "== Results =="
            print "Generated Nodes: ", results.generatedNodes
            print "Expanded Nodes: ", results.expandedNodes
            print "Path length: ", len(results.actions)
            print "Time (ns): ", results.time

            print
    else:
        if not quiet:
            print "Skipping non-existent file '%s'" % jsonFile

# TODO cleanup and remove code duplication
domainGroups = True
if numDomains != 1:
    if numAlgorithms < numDomains:
        print "Data grouped by algorithm, not by domain..."
        domainGroups = False
        if numAlgorithms != 1:
            print "Removing extra algorithms..."
            # Get max algorithm count
            maxAlgorithm = None
            maxCount = 0
            for key, value in algorithmCounts.iteritems():
                if value > maxCount:
                    maxCount = value
                    maxAlgorithm = key
            # Remove data from other algorithms
            for key, value in times.items():
                if key.algorithm != maxAlgorithm:
                    del times[key]
                    numAlgorithms -= 1
    else:
        print "Removing extra domains..."
        # Get max domain count
        maxDomain = None
        maxCount = 0
        for key, value in domainCounts.iteritems():
            if value > maxCount:
                maxCount = value
                maxDomain = key
        # Remove data from other domains
        for key, value in times.items():
            if key[DOMAIN] != maxDomain:
                del times[key]
                numDomains -= 1

# print times
# data = np.concatenate(times.values())
data = times.values()
# print data
datadata = np.array(data)

# print data
# print datadata
# print datadata.reshape(len(data[0]), len(data))

plt.ylabel("Goal Achievement Time (ms)")
labels = []
if domainGroups:
    assert numDomains == 1
    plt.xlabel("Algorithm")
    plt.title(translateDomainName(domainCounts.keys()[0]))
    for key in times.keys():  # Assumes same order will be plotted
        labels.append(translateAlgorithmName(key[ALGORITHM]))
else:
    assert numAlgorithms == 1
    plt.xlabel("Domain")
    plt.title(translateAlgorithmName(algorithmCounts.keys()[0]))
    for key in times.keys():
        labels.append(translateDomainName(key[DOMAIN]))

# print len(data)
x = np.arange(1, len(data) + 1)
y = data
# print x
# print y

# Get medians and stderr
# med = np.median(y, axis=1) # Can't do this way for uneven data points (no axis 1)
# sem = stats.sem(y, axis=1)
med = []
sem = []
for subdata in y:
    med.append(np.median(subdata))
    sem.append(stats.sem(subdata))

CI = stats.t.interval(0.95, len(y) - 1, loc=med, scale=sem)
# print 'CI',CI
# print CI[0]
# print CI[1]

plt.boxplot(y, notch=False, labels=labels)
plt.errorbar(x, med, yerr=(med - CI[0], CI[1] - med), fmt='none', linewidth=4)
# plt.errorbar(x, np.median(y, axis=0), yerr=CI)

# plt.boxplot(data, notch=True, labels=labels)
# plt.errorbar(np.arange(len(data)), data, yerr=np.std(data,axis=0))

# Save before showing since show resets the figures
if saveFile is not None:
    filename, ext = os.path.splitext(saveFile)
    if ext is '.pdf':
        from matplotlib.backends.backend_pdf import PdfPages
        pp = PdfPages(saveFile)
        plt.savefig(pp, format='pdf')
        pp.close()
    else:
        # Try and save it
        plt.savefig(saveFile)

if not quiet:
    plt.show()