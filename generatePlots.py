#!/usr/bin/python

# generatePlots.py
# This is a script for generating plots for data generated by the real time 
# search project.  The input is any number of result files in JSON format.  The 
# configuration entries will be read and the algorithms and domains will be 
# automatically separated.

import sys
import os
import getopt
import json
import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

ALGORITHM = 0
DOMAIN = 1


class Results:
    def __init__(self, parsedJson):
        self.configuration = (parsedJson['experimentConfiguration']['algorithmName'],
                              parsedJson['experimentConfiguration']['domainName'])
        self.generatedNodes = parsedJson['generatedNodes']
        self.expandedNodes = parsedJson['expandedNodes']
        self.actions = parsedJson['actions']
        self.time = parsedJson['nanoTime'] / 1000000 # convert to ms


script = os.path.basename(sys.argv[0])
options = "h"


def usage():
    print "usage:"
    print "{} [{}] file1 file2 ...".format(script, options)
    print "options:"
    print "  h         print this usage info"


try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], options)
except getopt.GetoptError:
    usage()
    sys.exit(2)

for opt, arg in opts:
    if opt in ('-h', '--help'):
        usage()
        sys.exit(0)
    else:
        usage()
        sys.exit(2)

# Process files from command line
numFiles = len(args)
if len(args) == 0:
    print "ERROR: No files provided"
    usage()
    sys.exit(2)

times = {}
domainCounts = {}
algorithmCounts = {}
numDomains = 0
numAlgorithms = 0
for jsonFile in args:
    if os.path.exists(jsonFile):
        f = open(jsonFile, 'r')
        results = Results(json.loads(f.read()))

        if results.configuration not in times:
            times[results.configuration] = []
        times[results.configuration].append(results.time)

        # Checking for common domain
        if results.configuration[DOMAIN] not in domainCounts:
            domainCounts[results.configuration[DOMAIN]] = 0
            numDomains += 1
        else:
            domainCounts[results.configuration[DOMAIN]] += 1

        # Checking for common algorithms
        if results.configuration[ALGORITHM] not in algorithmCounts:
            algorithmCounts[results.configuration[ALGORITHM]] = 0
            numAlgorithms += 1
        else:
            algorithmCounts[results.configuration[ALGORITHM]] += 1

        print "File: ", jsonFile
        print "== Configuration =="
        print "Algorithm: ", results.configuration[ALGORITHM]
        print "Domain: ", results.configuration[DOMAIN]

        print "== Results =="
        print "Generated Nodes: ", results.generatedNodes
        print "Expanded Nodes: ", results.expandedNodes
        print "Path length: ", len(results.actions)
        print "Time (ns): ", results.time

        print
    else:
        print "Skipping non-existent file '%s'" % jsonFile

# TODO cleanup and remove code duplication
domainGroups = True
if numDomains != 1:
    if numAlgorithms < numDomains:
        print "Data grouped by algorithm, not by domain..."
        domainGroups = False
        if numAlgorithms != 1:
            print "Removing extra algorithms..."
            # Get max algorithm count
            maxAlgorithm = None
            maxCount = 0
            for key, value in algorithmCounts.iteritems():
                if value > maxCount:
                    maxCount = value
                    maxAlgorithm = key
            # Remove data from other algorithms
            for key, value in times.items():
                if key.algorithm != maxAlgorithm:
                    del times[key]
                    numAlgorithms -= 1
    else:
        print "Removing extra domains..."
        # Get max domain count
        maxDomain = None
        maxCount = 0
        for key, value in domainCounts.iteritems():
            if value > maxCount:
                maxCount = value
                maxDomain = key
        # Remove data from other domains
        for key, value in times.items():
            if key[DOMAIN] != maxDomain:
                del times[key]
                numDomains -= 1

# print times
# data = np.concatenate(times.values())
data = times.values()
# print data
datadata = np.array(data)

# print data
# print datadata
# print datadata.reshape(len(data[0]), len(data))

plt.ylabel("Goal Achievement Time (ms)")
labels = []
if domainGroups:
    assert numDomains == 1
    plt.xlabel("Algorithm")
    plt.title(domainCounts.keys()[0])
    for key in times.keys():  # Assumes same order will be plotted
        labels.append(key[ALGORITHM])
else:
    assert numAlgorithms == 1
    plt.xlabel("Domain")
    plt.title(algorithmCounts.keys()[0])
    for key in times.keys():
        labels.append(key[DOMAIN])

# print len(data)
# x = np.arange(1, 5)
# y = np.random.randn(20, 4)
x = np.arange(1, len(data) + 1)
y = data
# print x
# print y
# TODO make work with different amounts of data per category


# low, high = bootstrap(y, 100000, np.median, 0.05)
med = np.median(y, axis=1)
# print 'median', med

CI = stats.t.interval(0.95, len(y)-1, loc=np.median(y, axis=1), scale=stats.sem(y, axis=1))
# print 'CI',CI
# print CI[0]
# print CI[1]

plt.boxplot(y, notch=False, labels=labels)
plt.errorbar(x, np.median(y, axis=1), yerr=(med - CI[0], CI[1] - med), fmt='none', linewidth=4)
# plt.errorbar(x, np.median(y, axis=0), yerr=CI)

# plt.boxplot(data, notch=True, labels=labels)
# plt.errorbar(np.arange(len(data)), data, yerr=np.std(data,axis=0))
plt.show()
